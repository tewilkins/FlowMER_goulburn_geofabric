### ----- Functions script ----- ###

# Function equivalent to dplyr's spread function, taking a long-form table and
# converting to a wide-form, with rows and columns as specified by rows and
# cols. If values is NULL, resulting table is populated by zeros and ones.
# If values is a numeric vector, the table is populated by the values aggregated
# by the supplied function (default sum)

ct <- function (rows, 
                cols, 
                values = NULL, 
                FUN = sum, 
                convertNAToZero = TRUE,...) 
{
  if(!is.vector(rows)) rows <- as.vector(rows)
  if(!is.vector(cols)) cols <- as.vector(cols)
  if(is.null(values)) values <- rep(1,length(rows))
  results <- tapply(values, list(rows, cols), FUN, ...)
  if(convertNAToZero)
    results[is.na(results)] <- 0
  results
}

# Helper function generated by ChatGPT:
save_current_chunk <- function(label, output_dir = "figures/", output_file = NULL) {
  if (!requireNamespace("rstudioapi", quietly = TRUE)) {
    stop("rstudioapi package is required for this function.")
  }
  
  ctx <- rstudioapi::getSourceEditorContext()
  doc_lines <- ctx$contents
  
  start <- grep(paste0("^#\\| label: ", label), doc_lines)
  if (length(start) == 0) stop("Label not found")
  
  # Remove control options from code
  knitr_end <- 0
  for (line in doc_lines){
    if (substr(line, 1, 2) == "#|"){
      knitr_end <- knitr_end + 1
    }
  }
  
  chunk <- doc_lines[(start + knitr_end):length(doc_lines)]
  next_label <- grep("^#\\| label:", chunk[-1])
  if (length(next_label)) {
    chunk <- chunk[1:(next_label[1])]
  }
  
  chunk <- gsub("save_current_chunk\\(.*", "", chunk)
  
  if (is.null(output_file)) {
    output_file <- paste0(label, ".R")
  }
  
  writeLines(chunk, paste0(output_dir, output_file))
}

# requiredPackages <- c("readxl","tidyverse", "flextable", "rio", "rstan", "spdep", "geosphere")
load_packages <- function(requiredPackages, lib.loc = .libPaths()){
  for (p in 1:length(requiredPackages)){
    if(require(requiredPackages[p], lib.loc = lib.loc, character.only = TRUE)){
      print(paste0(requiredPackages[p], " is loaded correctly"))
    } else {
      print(paste0("installing ", requiredPackages[p], "..."))
      install.packages(paste0(requiredPackages[p]), lib.loc = lib.loc)
      if(require(requiredPackages[p], lib.loc = lib.loc, character.only = TRUE)){
        print(paste0(requiredPackages[p], " is installed and loaded"))
      } else {
        stop(paste0("could not install ", requiredPackages[p]))
      }
    }
  }
}

# Calc EBFMI from stanfit object:
check_energy <- function(stanfit){
  sampler_params <- get_sampler_params(stanfit, inc_warmup=FALSE)
  EBFMI <- rep(0, times = length(sampler_params))
  for (n in 1:length(sampler_params)) {
    energies <- sampler_params[n][[1]][,'energy__']
    numer <- sum(diff(energies)**2) / length(energies)
    denom <- var(energies)
    EBFMI[n] <- numer / denom
  }
  return(EBFMI)
}

# Get number of divergent transitions from a stanfit obejct
num_divergent <- function(stanfit){
  sampler_params <- get_sampler_params(stanfit, inc_warmup=FALSE)
  num_divergent_per_chain <- sapply(sampler_params, function(x) sum(x[, "divergent__"]))
  num_divergent_all_chains <- sum(num_divergent_per_chain)
  return(num_divergent_all_chains)
}

# makes a layout of specified columns and rows. split_x allows the last row to be either column specific or column shared.
makeLayout <- function(cols, rows, split_x = FALSE, split_y = FALSE, nudge = 0, nudge_x = 0, nudge_y = 0){
  lo_vector <- integer()
  y_rows <- 0
  for (i in 1:rows-1){
    if (split_y == FALSE){
      lo_vector <- c(lo_vector, cols*rows+1, (1:cols)+(i*cols))
    } 
    if (split_y == TRUE){
      lo_vector <- c(lo_vector, cols*rows+1+i, (1:cols)+(i*cols))
      y_rows <- i
    }
  }
  if (split_x == FALSE){
    lo_vector <- c(lo_vector, 0, rep(cols*rows+2+y_rows, times = cols))
  }
  if (split_x == TRUE){
    lo_vector <- c(lo_vector, 0, seq(from = cols*rows+2+y_rows, by = 1, length.out = cols))
  }
  lo <- layout(matrix(lo_vector, ncol = cols+1, byrow = T), widths = c(1+(cols/1.5) - (nudge + nudge_y), rep(5, times = cols)), heights = c(rep(5, times = rows), 2 - (nudge + nudge_x)))
  return(lo)
}